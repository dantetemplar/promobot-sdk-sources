MEdu

SDK: Управление манипулятором Medu с помощью Python
===================================================

Документация по использованию Python SDK для манипуляторов ПРОМОБОТ

### Содержание

*   [1\. Введение и Обзор](#intro)
*   [2\. Архитектура](#architecture)
*   [3\. Типы команд](#commands)
*   [4\. Структура программы](#structure)
*   [5\. Примеры](#examples)
*   [6\. Работа с насадками](#attachments)
*   [7\. Стриминг](#streaming)
*   [8\. Программы](#programs)
*   [9\. Остановка движений](#stop)
*   [10\. Состояния и данные](#states)
*   [11\. Конвейер](#conveyor)
*   [12\. Управление GPIO](#gpio)
*   [Заключение](#conclusion)

1\. Введение и Обзор
--------------------

Python SDK — это библиотека от компании «ПРОМОБОТ», предназначенная для программного управления манипуляторами через приложение M Control. SDK позволяет отправлять команды и получать обратную связь от робота. Библиотека распространяется бесплатно и может быть установлена на персональные компьютеры.

**Требование к сети:** манипулятор и компьютер должны быть доступны друг другу по сети (локально или через Интернет).

**Требование к Python:** установите Python `3.12`, создайте виртуальное окружение и используйте его для запуска SDK — это обеспечит воспроизводимость и отсутствие конфликтов с системными пакетами.

SDK требует наличия Python **3.12**. Ниже — краткие инструкции по проверке и установке на популярных платформах, а также рекомендация по использованию виртуального окружения.

### Проверка версии

Копировать`python3.12 --version # или, если система использует "python" python --version`

Ожидаемый вывод: `Python 3.12.x`. Если команда не найдена или версия ниже — нужно установить/обновить.

### Установка

*   **Ubuntu / Debian (пример)**:
    
    Копировать`sudo apt update sudo apt install -y python3.12 python3.12-venv python3.12-distutils`
    
*   **Fedora / CentOS / RHEL**: используйте пакетный менеджер дистрибутива или сборку из исходников; можно также установить через `pyenv`.
*   **macOS (Homebrew)**:
    
    Копировать`brew update brew install python@3.12`
    
*   **Windows**: скачайте официальный инсталлятор Python 3.12 с python.org и выполните установку, включив опцию _"Add Python to PATH"_. После установки проверьте в PowerShell:
    
    Копировать`python --version`
    
*   **Переиспользование нескольких версий — pyenv** (рекомендуется разработчикам):
    
    Копировать`# установка pyenv (пример) curl https://pyenv.run | bash  # затем  pyenv install 3.12.0 pyenv global 3.12.0`
    

### Виртуальное окружение (обязательно для проекта)

Рекомендуется запускать SDK внутри виртуального окружения, созданного той же версией Python 3.12.

Копировать`# создать venv python3.12 -m venv .venv  # Linux / macOS  source .venv/bin/activate  # Windows (PowerShell)  .venv\Scripts\Activate.ps1  # обновить pip/setuptools  python -m pip install --upgrade pip setuptools wheel`

2\. Описание архитектуры программного обеспечения
-------------------------------------------------

Доступны два способа программирования: визуальный (Blockly) и программирование через SDK. Оба способа в итоге выполняют код на манипуляторе.

Взаимодействие построено по модели клиент — сервер с использованием протокола MQTT.

**Ключевые компоненты**

*   **Клиент:** компьютер пользователя / приложение с SDK.
*   **Сервер (pm\_develop\_api):** работает на манипуляторе и обрабатывает команды.
*   **M Control:** приложение с собственным SDK, которое переводит действия GUI в ROS2/rosbridge команды.

Сервер не только принимает команды, но и возвращает ответы, а также ведет стриминг текущих декартовых координат и состояния суставов.

3\. Типы команд
---------------

SDK поддерживает несколько типов команд для гибкого управления:

*   **Синхронные** — выполняются по очереди и блокируют выполнение до завершения: manipulator.get\_control().
*   **Асинхронные** — не блокируют выполнение; имеют суффикс `_async` и варианты с возможностью ожидания (async/await).
*   **Стриминговые** — для реального управления малыми шагами (скорости, позы, суставы).
*   **no\_wait** — аналог асинхронного метода, но без возможности ожидания результата.

**Примеры вызовов**

Копировать`# синхронный manipulator.get_control()  # асинхронный (awaitable) await manipulator.get_control_async_await()  #стриминговый for (int i = 0; i < 5; ++i) {     manipulator.stream_cartesian_velocities(lin, ang);     std::this_thread::sleep_for(std::chrono::milliseconds(100)); }  # no_wait manipulator.get_control_no_wait()`

Далее в примерах будут использоваться синхронные методы.

4\. Программные блоки (Структура программы)
-------------------------------------------

Структуру программы удобно разбить на логические блоки:

1.  Подключение библиотек и зависимостей.
2.  Подключение к манипулятору и захват управления.
3.  Основной блок выполнения (движения, чтение данных).
4.  Завершающий блок — опционально (отключение, освобождение ресурсов).

Ниже — минимальный пример подключения и захвата управления.

Копировать`from sdk.manipulators.medu import MEdu  host = "192.168.88.182" #IP манипулятора client_id = "122"       #ID клиента login = "13"            #Логин password = "14"         #Пароль  manipulator = MEdu(host, client_id, login, password) manipulator.connect() manipulator.get_control()`

5\. Примеры движений
--------------------

### 5.1 Движение по углам

У MEdu три управляемых угла: основание, плечо, стрела.

Копировать`# Пример: move_to_angles manipulator.move_to_angles(     povorot_osnovaniya=0.05,    # угол поворота основания [рад]     privod_plecha=-0.35,        # угол плеча [рад]     privod_strely=-0.75,        # угол стрелы [рад]     v_osnovaniya=0.0,           # скорость основания [рад/с]     v_plecha=0.0,               # скорость плеча [рад/с]     v_strely=0.0,               # скорость стрелы [рад/с]     velocity_factor=0.1,        # коэффициент скорости     acceleration_factor=0.1,    # коэффициент ускорения )`

**Параметры:**

*   **povorot\_osnovaniya** (float, обязательный): угол поворота основания в радианах
*   **privod\_plecha** (float, обязательный): угол плеча в радианах
*   **privod\_strely** (float, обязательный): угол стрелы в радианах
*   **v\_osnovaniya** (float, опциональный, по умолчанию 0.0): скорость основания в рад/с
*   **v\_plecha** (float, опциональный, по умолчанию 0.0): скорость плеча в рад/с
*   **v\_strely** (float, опциональный, по умолчанию 0.0): скорость стрелы в рад/с
*   **velocity\_factor** (float, опциональный, по умолчанию 0.1): коэффициент скорости (0.0-1.0)
*   **acceleration\_factor** (float, опциональный, по умолчанию 0.1): коэффициент ускорения (0.0-1.0)
*   **timeout\_seconds** (float, опциональный, по умолчанию 60.0): таймаут операции в секундах
*   **throw\_error** (bool, опциональный, по умолчанию True): выбрасывать исключение при ошибке

### 5.2 Движение по координатам

Копировать`from sdk.commands.move_coordinates_command import MoveCoordinatesParamsPosition, MoveCoordinatesParamsOrientation  position = MoveCoordinatesParamsPosition(0.32, -0.004, 0.25) orientation = MoveCoordinatesParamsOrientation(0, 0, 0, 1.0)  manipulator.move_to_coordinates(position, orientation, velocity_scaling_factor=0.1, acceleration_scaling_factor=0.1, planner_type=PlannerType.LIN, timeout_seconds=30.0, throw_error=True)`

**Параметры:**

*   **position**: позиция — объект с полями `x, y, z`.
*   **orientation**: ориентация — объект с полями `x, y, z, w`.
*   **velocity\_scaling\_factor**: коэффициент скорости (доля от максимальной скорости, по умолчанию `0.1`).
*   **acceleration\_scaling\_factor**: коэффициент ускорения (доля от максимального ускорения, по умолчанию `0.1`).
*   **planner\_type**: тип планировщика (по умолчанию `PlannerType.LIN`).
*   **timeout\_seconds**: таймаут ожидания завершения (секунды).
*   **throw\_error**: выбрасывать исключение при ошибке (по умолчанию `True`).

### Примечания

*   В случае, если движение манипулятора не происхоит и возникает ошибка расчетов траектории, указывайте более точные координаты.

Копировать`START_POSITION = MoveCoordinatesParamsPosition(         0.2279991579119544, -0.25677241023135805, 0.24713621034095856)`

### 5.3 Движение по дуге

Копировать`from sdk.commands.arc_motion import ArcMotion, Pose, Position   target = Pose(position=Position(target_x, target_y, target_z), orientation=Orientation()) center_arc = Pose(position=Position(center_x, center_y, center_z), orientation=Orientation())  manipulator.arc_motion(target, center_arc, step=0.05, count_point_arc=50, max_velocity_scaling_factor=0.5, max_acceleration_scaling_factor=0.5)`

**Параметры:**

*   **target**: целевая точка (объект с `position` и `orientation`).
*   **center\_arc**: точка центра дуги (объект с `position` и `orientation`).
*   **step**: шаг между точками дуги (по умолчанию `0.05`).
*   **count\_point\_arc**: количество точек для аппроксимации дуги (по умолчанию `50`).
*   **max\_velocity\_scaling\_factor**: максимальный масштаб скорости (по умолчанию `0.5`).
*   **max\_acceleration\_scaling\_factor**: максимальный масштаб ускорения (по умолчанию `0.5`).
*   **timeout\_seconds**: таймаут ожидания завершения (секунды).
*   **throw\_error**: выбрасывать исключение при ошибке (по умолчанию `True`).

6\. Работа с насадками
----------------------

**Насадка:** _Гриппер_ (Gripper) — механический захват для MEdu.

**Требования:**

*   Перед активацией насадки необходимо включить питание с помощью `manipulator.nozzle_power(True)`.

**Варианты работы:**

1.  **Прямой контроль через класс-насадку** — используйте `GripperAttachment` и его методы `activate`/`deactivate`. Подходит, когда нужно явно управлять захватом из кода и отслеживать статус команды.
2.  **Вызов через манипулятор** — например  
    `manipulator.manage_gripper(rotation=..., gripper=...)`

#### Примеры использования

    
    # 1) Прямой
    manipulator.nozzle_power(True)  # обязательно включить питание
    gripper = GripperAttachment(manipulator)
    gripper.activate(rotation=20, gripper=10)   # закрыть/захватить
    gripper.deactivate()                         # открыть
    
    # 2) Через манипулятор
    manipulator.nozzle_power(True)
    manipulator.manage_gripper(rotation=20, gripper=10)
      

**Параметры (activate):**

*   **rotation** — угол поворота насадки в градусах.
*   **gripper** — позиция/угол захвата в градусах.

7\. Стриминг
------------

Поддерживается управление в трех режимах: **TWIST** (скорости), **POSE** (целевая поза), **JOINT\_JOG** (положение суставов).

Перед началом каждого стриминга необходимо включить соответствующий режим:

Копировать`from sdk.utils.enums import ServoControlType  # Режимы manipulator.set_servo_control_type(ServoControlType.TWIST) manipulator.set_servo_control_type(ServoControlType.POSE) manipulator.set_servo_control_type(ServoControlType.JOINT_JOG)  # Либо короткий вариант manipulator.set_servo_twist_mode()  # Для скорости manipulator.set_servo_pose_mode()   # Для позы manipulator.set_servo_joint_jog_mode()  # Для суставов`

### Стриминг скоростей

Копировать`# Включаем режим TWIST manipulator.set_servo_twist_mode()  linear_vel = {"x": 0.02, "y": 0, "z": 0} angular_vel = {"rx": 0, "ry": 0, "rz": 0.01} manipulator.stream_cartesian_velocities(linear_vel, angular_vel)`

**Параметры (stream\_cartesian\_velocities):**

*   **position**: позиция (объект с `x, y, z`).
*   **velocities**: скорость (объект с `rx, ry, rz`).
*   **header**: информация о штампе времени и системе координат (по умолчанию `now` и `base_link`).

### Стриминг позы

Копировать`# Включаем режим POSE manipulator.set_servo_pose_mode()  position = MoveCoordinatesParamsPosition(0.27, 0.0, 0.15) orientation = MoveCoordinatesParamsOrientation(0, 0, 0, 1) manipulator.stream_coordinates(position, orientation)`

**Параметры (stream\_coordinates):**

*   **position**: позиция (объект с `x, y, z`).
*   **orientation**: ориентация (объект с `x, y, z, w`).
*   **header**: информация о штампе времени и системе координат (по умолчанию `now` и `base_link`).

### Стриминг суставов

Копировать`# Включаем режим JOINT_JOG manipulator.set_servo_joint_jog_mode()  manipulator.stream_joint_angles(     povorot_osnovaniya=0.5, privod_plecha=1.0, privod_strely=0.8,     v_osnovaniya=0.2, v_plecha=0.1, v_strely=0.15 )`

**Параметры (stream\_joint\_angles):**

*   **povorot\_osnovaniya, privod\_plecha, privod\_strely**: позиции (углы) для каждого сустава.
*   **v\_osnovaniya, v\_plecha, v\_strely**: скорости для каждого сустава.
*   **header**: информация о штампе времени и системе координат (опционально).

8\. Программы
-------------

SDK позволяет запускать готовые программы, JSON-сценарии и выполнять Python-код прямо на роботе.

Копировать`# Запуск готовой программы manipulator.run_program('edum/default')  # Запуск JSON-программы program_json = {   'Root':[{'Move':{'content':[{'Point':{'positions':[0.3,-0.3,-0.4],'time':0.5}}],'type':'Simple'}}] } manipulator.run_program_json('program_1', program_json)  # Запуск Python-кода на роботе manipulator.run_python_program("print('Hello!')")`

**Параметры (run\_program):**

*   **name**: название программы (строка).

**Параметры (run\_program\_json):**

*   **name**: название программы (строка).
*   **json**: JSON-программа — объект с корневым ключом `Root` и массивом команд.

**Параметры (run\_python\_program):**

*   **code**: строка с Python-кодом для выполнения на роботе.

9\. Остановка движениями
------------------------

Остановка всего движения с таймаутом.

Копировать`manipulator.stop_movement(timeout_seconds=5.0)`

10\. Состояния и данные
-----------------------

Методы для получения состояния манипулятора и подписок:

*   `manipulator.get_joint_state()` — текущие углы суставов.
*   `manipulator.get_home_position()` — домашняя позиция.
*   `manipulator.get_cartesian_coordinates()` — текущие координаты X, Y, Z.
*   `manipulator.subscribe_hardware_error()` — подписка на ошибки оборудования.

Ошибки возвращаются в формате JSON: `{"type": id, "message": "..."}`

11\. Конвейерная лента (MGbot)
------------------------------

Управление конвейерной лентой и связанными устройствами.

Копировать`# Установить скорость мотора (0..100) manipulator.mgbot_conveyer.set_speed_motors(10)  # Повернуть сервопривод manipulator.mgbot_conveyer.set_servo_angle(45)  # Установить цвет светодиода (0..255) manipulator.mgbot_conveyer.set_led_color(255, 0, 0)  # Показать текст на дисплее manipulator.mgbot_conveyer.display_text('Hello')  # Звуковой сигнал (1..15) manipulator.mgbot_conveyer.set_buzz_tone(10)  # Чтение датчиков sensor_data = manipulator.mgbot_conveyer.get_sensors_data(True) # Возвращаемые поля: "DistanceSensor", "ColorSensor", "Prox"`

**Параметры:**

*   **set\_speed\_motors(speed)**: задает скорость мотора в диапазоне `0..100`.
*   **set\_servo\_angle(angle)**: поворачивает сервопривод (градусы).
*   **set\_led\_color(r, g, b)**: задает цвет светодиодов (каждый канал `0..255`).
*   **display\_text(text)**: показывает текст на дисплее конвейера (utf-8).
*   **set\_buzz\_tone(level)**: подает звуковой сигнал в диапазоне `1..15`.
*   **get\_sensors\_data(enabled)**: получить данные с датчиков. `True` — данные возвращаются в виде JSON.

**Возвращаемые данные (sensor\_data):**

*   **DistanceSensor** — значение расстояния / показания дистанционного датчика.
*   **ColorSensor** — объект с полями `R`, `G`, `B`, `Prox` (например `{"R":97,"G":114,"B":108,"Prox":50}`).
*   **Prox** — значение приближения к `ColorSensor`.

**Инструкция по подключению**

1.  Подключите кабель USB к разъёму на конвейере и к разъёму USB на задней панели манипулятора.
2.  Подключите кабель питания в разъём рядом с USB-портом. При подаче питания моторы кратковременно инициализируются и могут сделать короткое движение.
3.  Проверьте индикацию светодиодов на плате конвейера:
    *   **LED1 (синий):** горит, когда есть питание 5 В через USB-порт.
    *   **LED2 (красный):** горит, когда есть питание от внешнего источника 8–30 В.
    *   **LED3 (розовый):** управляется через GPIO4 (режим выхода или ШИМ).

**Важные предупреждения и рекомендации**

*   **Разъем Type-C:** контроллер чувствителен к ориентации кабеля USB-C. Если устройство не определяется — попробуйте аккуратно перевернуть разъем кабеля и повторно подключить.
*   **Проблемы со стартом/остановкой ленты:** если лента не начинает движение или не останавливается, аккуратно приподнимите стеклянную крышку и нажмите кнопку _RESET_ слева от платы конвейера.
*   **Подключение по Wi-Fi:** при отправке команд через Wi-Fi убедитесь в стабильном соединении и достаточной пропускной способности сети — нестабильный Wi-Fi может приводить к потерям команд и задержкам.
*   **Подсветка дисплея:** при подключении USB-кабеля к манипулятору возможна потеря яркости дисплея ленты — это нормальное поведение.
*   **Не работают сенсорные датчики:** в случае отсутствия показаний сенсоров попробуйте перезапустить манипулятор. Если проблема сохраняется — проверьте подключение кабелей или обратитесь в техподдержку ПРОМОБОТ.

12\. Управление GPIO
--------------------

GPIO (General Purpose Input/Output) позволяет управлять цифровыми входами и выходами манипулятора. Это полезно для взаимодействия с внешними устройствами, датчиками, светодиодами и другими периферийными компонентами.

### Основные методы

Копировать`# Синхронная запись в GPIO manipulator.write_gpio(name, value, timeout_seconds=60.0, throw_error=True)  # Чтение значения GPIO manipulator.get_gpio_value(name, timeout_seconds=60.0, throw_error=True)`

### Параметры

*   **name**: имя GPIO-пина (строка)
*   **value**: значение для записи (0 или 1)
*   **timeout\_seconds**: таймаут выполнения команды (по умолчанию 60.0)
*   **throw\_error**: выбрасывать исключение при ошибке (по умолчанию True)

**Важные предупреждения**

*   **get\_gpio\_value:** доступен только синхронный метод.

### Пример использования

Копировать`# Определение имени GPIO-пина gpio_name = "/dev/gpiochip4/e1_pin"  # Функция для управления светодиодом def set_led(on: bool):     try:         manipulator.write_gpio(gpio_name, 1 if on else 0, timeout_seconds=0.5, throw_error=False)     except Exception as e:         print(f"Ошибка управления GPIO: {e}")  # Использование set_led(True)   # Включить светодиод set_led(False)  # Выключить светодиод`

### Типичные сценарии использования

*   Управление внешними светодиодами или индикаторами
*   Включение/выключение периферийных устройств
*   Взаимодействие с простыми датчиками
*   Создание световых сигналов о состоянии системы

13\. Воспроизведение аудио
--------------------------

Манипулятор поддерживает воспроизведение аудиофайлов. Это может быть полезно для звуковых уведомлений, предупреждений или интерактивных сценариев.

### Основные методы

Копировать`# Синхронное воспроизведение аудио manipulator.play_audio(file_name, timeout_seconds=60.0, throw_error=True)`

### Параметры

*   **file\_name**: имя аудиофайла (строка). Файл должен находиться в доступной директории манипулятора.
*   **timeout\_seconds**: таймаут выполнения команды (по умолчанию 60.0)
*   **throw\_error**: выбрасывать исключение при ошибке (по умолчанию True)

### Примеры использования

#### Синхронное воспроизведение

Копировать`# Простое воспроизведение аудиофайла try:     manipulator.play_audio('start.wav')     print("Аудиофайл воспроизведен успешно") except Exception as e:     print(f"Ошибка воспроизведения аудио: {e}")`

### Типичные сценарии использования

*   Звуковые уведомления о начале/завершении операции
*   Предупреждающие сигналы при ошибках
*   Интерактивные сценарии с обратной связью
*   Озвучивание состояния системы

### Примечания

*   Поддерживаются распространенные аудиоформаты (WAV, MP3)
*   Файлы должны быть предварительно загружены на манипулятор
*   Воспроизведение выполняется через встроенную аудиосистему манипулятора

Примеры использования команд
----------------------------

В составе SDK предоставлены примеры, демонстрирующие использование основных команд управления манипулятором и дополнительными модулями. Они позволяют ознакомиться с базовыми возможностями, а также служат отправной точкой для разработки собственных сценариев.

Примеры включают вызовы для перемещения по координатам, управления гриппером и другой функциональности. Их рекомендуется использовать для первичного ознакомления и проверки работоспособности системы.

Заключение
----------

Если возникли проблемы — используйте диагностические инструменты SDK и обращайтесь в техническую поддержку ПРОМОБОТ с подробными логами.

**Рекомендация:** Для повышения надежности исполнения все вызовы команд следует оборачивать в конструкцию `try/except`, чтобы корректно обрабатывать возможные ошибки при взаимодействии с манипулятором.

Версия SDK: **0.6.8**

© ПРОМОБОТ
